#+TITLE: Fennel - The Book
#+OPTIONS: html-style:nil
#+BIND: org-html-table-default-attributes (:border "0" :frame "void")
#+LATEX_CLASS: book-without-parts
#+LATEX_HEADER: \usemintedstyle{tango}
#+LATEX_HEADER: \hypersetup{colorlinks=true,urlcolor=blue,linkcolor=blue}
#+LATEX_HEADER: \AtBeginEnvironment{minted}{%
#+LATEX_HEADER:  \renewcommand{\fcolorbox}[4][]{#4}}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="fennel-the-book.css" />
#+HTML_HEAD: <script type="text/javascript" src="fengari-web.js"></script>
#+HTML_HEAD: <script type="application/lua" src="fennel-the-book-html-script.lua" async></script>
#+HTML_HEAD_EXTRA:

* Introduction
This book is intended to be a complete reimplementation of [[https://fennel-lang.org][Fennel]],
along with associated tooling that reuses the compiler
infrastructure. It was developed by adapting the [[https://github.com/bakpakin/fennel][original Fennel
compiler]]. I could not have written any of this without basing it on
the work others have put into creating and maintaining the Fennel
language.

** How to read this book
This book is also a program! It is written using the [[https://en.wikipedia.org/wiki/Literate_programming][literate
programming]] style, which means that the source code you read in this
book is /also/ the source code of the program the book is about.

When a code block is /not/ part of the compiler's source code, it will
have a comment at the beginning saying so. It will look like this:

#+BEGIN_SRC fennel
;; Example - not a part of the source code!
#+END_SRC

The compiler is a single Fennel file. When a code block is part of a
different file, it will have a comment at the beginning stating so.

Note also that the source code blocks in this book are arranged for
the purpose of reading, and do not necessarily appear in the same
order in the source code itself. For instance, much of the preamble of
the compiler is left until the end, since it's largely miscellaneous
boilerplate that doesn't contribute to an understanding of the code.

** What is Fennel?
Fennel is a language that compiles to [[https://www.lua.org/][Lua]]. It's part of the Lisp
language family, which includes languages like Common Lisp, Clojure,
Racket, and Scheme.

The Fennel compiler is a Lua program - the original compiler was
written by hand in Lua, and the compiler in this book compiles to
Lua. When you run a Fennel program, it is first compiled into Lua code
and then run by the Lua interpreter. Running Fennel from the command
line once you have it installed looks like this:

#+BEGIN_SRC bash :exports both :results output
# Example - not a part of the source code!
fennel --eval "(+ 1 1)"
#+END_SRC

#+RESULTS:
: 2

You can also compile code to Lua ahead of time and then run it with a
Lua interpreter, e.g.:

#+BEGIN_SRC bash :exports both :results output
# Example - not a part of the source code!
echo '(print (.. "hello " "world!"))' |
  fennel --compile -   |         # compile fennel from stdin
  tee compiled.lua     |         # copy the output to compiled.fnl
  xargs -0 printf 'compiled: %s' # print the output
printf "output:   $(lua compiled.lua)"
#+END_SRC

#+RESULTS:
: compiled: return print(("hello " .. "world!"))
: output:   hello world!

** Test file header :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
((require :busted.runner))

(global describe describe)
(global assert assert)
(global it it)

(global unpack (or unpack table.unpack))
#+END_SRC

** TODO COMMENT Self-hosting
The compiler implemented in this book cannot compile itself yet. In
fact, it's not even a compiler yet! In order to run what /is/
implemented in the book, you'll need to download the Fennel compiler
and put it on your ~$PATH~ as ~fennel~.

*** DONE explain ~$PATH~ and Fennel installation                 :noexport:

** TODO COMMENT Introduction to ASCII and UTF-8
** TODO COMMENT Real credits
Replace the vague credit in the intro with real credits section
including Fennel contributors.

** DONE COMMENT Get ~fennel --eval~ upstreamed
* TODO COMMENT A Dash of Fennel
* Iterators and Streams
A construct we'll use frequently throughout the book is the /stream/.
Streams are a functions which output data sequentially. If you've ever
used an iterator like ~pairs~ or ~ipairs~ in Lua, you've already used
one - the function that is returned by those iterators is a stream.

 Just as there are two kinds of iterators in Lua, there are likewise
 two kinds of streams - /stateful/ and /stateless/.

** Stateful Streams
Stateful streams capture the state of the stream within a closure (or
a coroutine). They ignore any arguments, and return the next element
of the stream each time they are called.  Here's a function which
creates a stateful stream that returns each byte in a string
successively:

#+BEGIN_SRC fennel :results output
(fn string-bytes [str]
  (var index 1)
  #(let [r (: str :byte index)]
     (set index (+ index 1))
     r))

(each [byte (string-bytes "abc")]
  (print (.. byte " " (string.char byte))))
#+END_SRC

#+RESULTS:
: 97 a
: 98 b
: 99 c

Stateful streams are less flexible - because the state is stored
within the closure, there's no way to set the state from outside the
stream. One of the most important implications of stateful streams is
that you can only traverse the stream once.

Some streams are inherently stateful. For instance, the data returned
by ~(io.read)~ is only returned once, and calling it again will result
in new data being returned. Here's how we could turn that into a
stateful stream:

#+BEGIN_SRC fennel
(local chunk-size (^ 2 13)) ;; 8kb
(fn file-chunks [filename]
  (local f (if filename (io.open filename :r)
               io.stdin))
  #(let [chunk (: f :read chunk-size)]
     (when (not chunk) (: f :close))
     chunk))
#+END_SRC

** Stateless Streams
/Stateless/ streams have their state passed in using two arguments:
the /invariant state/ and the /variant state/. Each time the stream
is called, it must be passed the two state values as arguments. The
stream should then return two values: the new variant state and the
streamed value.

To illustrate this more concretely, let's take a look at the iterator
~ipairs~, which returns a stateless stream. In ~ipairs~' case, the
invariant state is the table containing the elements, and the variant
state is the current index of the stream.

#+BEGIN_SRC fennel :results output :exports both
;; Example - not a part of the source code!
(local fennelview #((require :fennelview) $ {:one-line true}))

(let [letters [:a :b :c]
      ;; the invariant state is the array, and the variant state is
      ;; the last index (starting at 0)
      (stream arr initial-i) (ipairs letters)]

  ;; Manually iterate the stream
  (var i initial-i)
  (while i
    (let [(new-i value) (stream arr i)]
      (set i new-i)
      (print (fennelview {: arr : i : value}))))

  ;; Manually iterate the stream once with a different table and index
  (let [arr [:d :e :f]
        initial-i 1
        (i value) (stream arr initial-i)]
    (print (fennelview {: arr :i i : value}))))
#+END_SRC

#+RESULTS:
: {:arr ["a" "b" "c"] :i 1 :value "a"}
: {:arr ["a" "b" "c"] :i 2 :value "b"}
: {:arr ["a" "b" "c"] :i 3 :value "c"}
: {:arr ["a" "b" "c"]}
: {:arr ["d" "e" "f"] :i 2 :value "e"}

** Intro to Streams: ~stateful-string-stream~
As both an example and a helper function for later use, let's define a
function that creates a stateful stream from a string:

#+BEGIN_SRC fennel :noweb-ref stateful-string-stream
(fn stateful-string-stream [str]
  (var index 1)
  #(let [r (: str :byte index)]
     (set index (+ index 1))
     r))
#+END_SRC

We return an anonymous function which closes over ~str~ and ~index~,
maintaing the state in the function itself. Each time it is called, it
will return the next byte in the string.

One handy feature of this design is that these streams are also
iterators! For instance, using ~stateful-string-stream~ we can print
the bytes of a string with the following code:

#+BEGIN_SRC fennel :exports both :noweb yes
;; EXAMPLE - not a part of the source code!
(local {:streams {: stateful-string-stream}} (require :fennel-the-book))
(each [byte (stateful-string-stream "abc")]
  (: io.stdout :write (.. byte " ")))
#+END_SRC

#+RESULTS:
: 97 98 99 nil

*** Tests                                                        :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe "stateful-string-stream"
  #(let [{:streams {: stateful-string-stream}} (require :fennel-the-book)]
     (it "should stream a string"
       #(let [the-stream (stateful-string-stream "abcd")]
          (assert.are.equal 97 (the-stream))
          (assert.are.equal 98 (the-stream))
          (assert.are.equal 99 (the-stream))
          (assert.are.equal 100 (the-stream))))))
#+END_SRC

** COMMENT Transforming streams - ~map~, ~filter~, ~reduce~
It is often useful to be able to express a program as a functional
transformation of streams. This is directly analogous to transforming
lists or arrays, and we can use the same terminology:

- ~map-stream~ should return a new stream that outputs one element for
  each element of the original stream, transforming it with a
  function.
- ~filter-stream~ should return a new stream that outputs one or zero
  elements for each element of the original stream, based on the
  return value of calling its predicate function on the element. The
  remaining elements are unchanged by the filter.
- ~reduce-stream~ should return a new stream that outputs items based on
  consuming the original stream. The elements it outputs may have an
  arbitrary relationship to the elements output by the original
  stream - one-to-one, many-to-one, one-to-many, or a mixture of
  these.

These operations match many of the operations we need to perform in
the compiler:

- Tokenizing is a ~reduce~ of bytes to a smaller number of tokens.
- Comment elimination is a ~filter~ removing comment tokens from the
  token stream.
- Parsing is a ~reduce~ of tokens to a smaller number of forms.
- Compiling is a (recursive) ~map~ of AST forms to strings of Lua code.

** Buffering stateful streams with ~create-cursor~
:PROPERTIES:
:CUSTOM_ID: get-stream-cursor
:END:
The tokenizer we will implement in the next chapter will be using the
~stateful-string-stream~ we just defined to stream the bytes of the code
it's digesting. However, the stream we've defined can be awkward to
use - without keeping track of things manually we can't check bytes
ahead of the stream's current position without advancing the
stream. This gets quite messy to deal with, since you can't just pass
the stream to a function if you might need to send buffered data or
both instead.

To remedy this, we'll define a simple abstraction over a stateful
stream called a ~cursor~. The cursor is a table with two main functions
that provide access to the values in the stream - ~take~ and ~peek~.

~cursor.take~ is itself a stateful stream - if you create a cursor that
wraps a stateful stream and iterate over ~cursor.take~, you will get
exactly the same values as if you iterated over the original stream.

~cursor.peek~, on the other hand, lets you look at the upcoming values
of ~cursor.take~. It does so by calling the original stream and then
storing the value it returns in a buffer. When ~cursor.take~ is called,
it returns any values in the buffer before returning values from the
original stream.

#+BEGIN_SRC fennel :noweb-ref create-cursor
(fn create-cursor [stream]
  ;; We track the current position and the end of the buffer. The
  ;; indices of the buffer items will always be between these two
  ;; numbers. Since we don't move the buffer elements back to the
  ;; beginning at any point, these indices will increase
  ;; monotonically.
  (var position 0)
  (var buffer-end 0)
  (let [;; This is the buffer to store values that were retrieved
        ;; ahead of the cursor position
        buffer []
        buffer-length #(- buffer-end position)
        buffer-get #(. buffer (+ position $))
        buffer-set #(tset buffer (+ position $1) $2)
        buffer-push
        #(let [new-buffer-end (+ buffer-end 1)]
           (tset buffer new-buffer-end $)
           (set buffer-end new-buffer-end))]

    (fn buffer-load-and-get [i]
      (if (= i (+ 1 (buffer-length)))
          (let [new-item (stream)]
            (buffer-push new-item)
            new-item)
          (> i (buffer-length))
          (let [new-item (stream)]
            (buffer-push new-item)
            (buffer-load-and-get i))
          (let [old-item (buffer-get i)]
            old-item)))

    ;; Tail recursive peek lets us peek ahead multiple values without
    ;; allocating a table each time
    (local fennelview (require :fennelview))
    (fn peek [a b]
      (let [(i n) (match (values a b)
                    (an-i an-n) (values an-i an-n)
                    (an-n nil) (values 1 an-n)
                    (nil nil) (values 1 1))]
        (when (< n 1) (error "cannot peek at less than one value"))
        (if
         ;; Base case - return the remaining item
         (or (not n) (= n 1))
         (buffer-load-and-get i)
         ;; Otherwise, return the item at i and recursively iterate
         ;; until we've returned all the requested values
         (values (buffer-load-and-get i)
                 (peek (+ i 1) (- n 1))))))

    (fn take [n]
      (let [n (if (= n nil) 1 n)]
        (when (> n 0)
          (values
           (if (> (buffer-length) 0)
               (let [item (buffer-get 1)]
                 (buffer-set 1 nil)
                 (set position (+ position 1))
                 item)
               (do (set position (+ position 1))
                   (set buffer-end (+ buffer-end 1))
                   (stream)))
           (take (- n 1))))))

    {: peek : take}))
#+END_SRC

To demonstrate how this can be useful, let's try out our cursor with
some sample code:

#+BEGIN_SRC fennel :exports both :results output org drawer
;; Example - not a part of the source code!
(global unpack (or unpack table.unpack))
(let [{: print-table} (require :org-table-helpers)
      {:streams {: stateful-string-stream
                 : create-cursor}} (require :fennel-the-book)
      {: insert : concat} table
      stream (stateful-string-stream "abcdef")
      cursor (create-cursor stream)
      rows []]

  ;; Advance the stream of bytes by iterating over cursor.take
  (each [byte cursor.take]
    ;; Check the next byte after the cursor, then the next two bytes
    (let [peek-1-byte (cursor.peek)
          peek-2-bytes [(cursor.peek 2)]]
      (insert rows [[byte] [peek-1-byte] peek-2-bytes])))

  ;; Add an additional column of decoded characters for each column of bytes
  (each [i row (ipairs rows)]
    (local new-row [])
    (each [j bytes (ipairs row)]
      (each [_ byte (ipairs bytes)] (insert new-row byte))
      (when (and (= j 3) (< (length bytes) 2)) (insert new-row ""))
      (when (> (length bytes) 0)
        (insert new-row (string.char (unpack bytes)))))
    (tset rows i new-row))

  (print-table
   rows {:column-headers [:Current "" "Peek 1" "" "Peek 2"]
         :column-groups [:/ :> :< :> :< "" :>]
         }))
#+END_SRC

#+RESULTS:
:results:
| Current |   | Peek 1 |   | Peek 2 |     |    |
|---------+---+--------+---+--------+-----+----|
|       / | > |      < | > |      < |     | >  |
|      97 | a |     98 | b |     98 |  99 | bc |
|      98 | b |     99 | c |     99 | 100 | cd |
|      99 | c |    100 | d |    100 | 101 | de |
|     100 | d |    101 | e |    101 | 102 | ef |
|     101 | e |    102 | f |    102 |     | f  |
|     102 | f |        |   |        |     |    |
:end:

As you can see, the ~(cursor.peek)~ expression does not affect the
subsequent ~(cursor.peek 2)~ expression - the values only advance when
~cursor.take~ is called in the iterator.

For convenience in testing later functions, we'll also define
~create-string-cursor~ which creates a cursor that buffers the bytes of
a string:

#+BEGIN_SRC fennel :noweb-ref create-string-cursor
(fn create-string-cursor [s] (-> s stateful-string-stream create-cursor))
#+END_SRC

*** Tests                                                        :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe
 "create-cursor"
 #(let [{:streams {: create-string-cursor}} (require :fennel-the-book)
        fennelview (require :fennelview)
        sample-contents "abcdefghijklmnopqrstuvwxyz"]
    (it "should stream the alphabet"
        #(let [cursor (create-string-cursor sample-contents)
               result []]
           (var result-i 1)
           (each [byte cursor.take]
             (tset result result-i (string.char byte))
             (set result-i (+ result-i 1)))
           (assert.are.equal sample-contents (table.concat result))))
    (it "should allow peeking without changing the taken bytes"
        #(let [cursor (create-string-cursor sample-contents)]
           (assert.are.equal 97 (cursor.peek))
           (assert.are.same [97 98] [(cursor.peek 2)])
           (assert.are.same [98 99 100] [(cursor.peek 2 3)])
           (assert.are.equal 97 (cursor.take))
           (assert.are.equal 98 (cursor.peek))
           (assert.are.equal 98 (cursor.take))))))
#+END_SRC

** COMMENT Child cursors

#+BEGIN_SRC fennel
(fn create-child-cursor [cursor]
  (var position 1)
  (let [peek #(cursor.peek position (or $ 1))
        peek-at #(cursor.peek (+ position $1) $2)
        take (fn [n]
               (set position (+ position n))
               (cursor.peek (- position n) n))]
    {: peek : peek-at : take}))
#+END_SRC

*** Tests                                                        :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe "create-child-cursor"
  (it "should allow taking from a child cursor" #(let [] nil)))
#+END_SRC

* Tokenizing: Bytes and Pieces
The first step towards compiling code is /tokenizing/. Tokenizing is the
process of taking the source format of the language - in our case, a
UTF-8 string - and turning it into /tokens/. Tokens are the individual
instances of the basic elements of a languages grammar. Tokens are /not/
nested - for instance, we don't have a ~list~ token type, but rather
~opener~ and ~closer~ token types to indicate when a list begins and ends.

Each token is tagged with a /token type./ There is a finite number of
token types, as follows:

The total list of token types is as follows:

- String literals - e.g., ~"example"~
- Number literals - e.g., ~3.456e-7~ or ~0xabc123~
- Symbols - e.g., ~example~
- Keyword strings - e.g., ~:example~
- Openers - ~(~, ~[~, or ~{~
- Closers - ~)~, ~]~, or ~}~
- Prefix characters - ~'~, ~`~, ~,~, and ~#~
- Whitespace and comments

Whitespace tokens are mostly ignored by the parser, and comment tokens
are completely ignored, but we tokenize them anyway so that the
tokenizer can be re-used by other tooling, like a formatter for Fennel
code.

Since the number of token types is fixed and small, it's convenient to
use integers instead of strings to represent the token types. To do
so, we use a table that stores a mapping of string names to their
corresponding number values and predicate functions. The predicate
functions let us check the type readably without first converting the
number to a string:

#+BEGIN_SRC fennel :noweb-ref enum
(global unpack (or unpack table.unpack))
(macro enum [...]
  (let [cases [...]
        stringed-cases []]

    (each [i case (ipairs cases)]
      (let [stringed-case (tostring case)]
        ;; (tset kv-pairs adjusted-i [i stringed-case])
        ;; (tset kv-pairs (+ adjusted-i 1) [stringed-case i])
        ;; (tset kv-pairs (+ adjusted-i 2) [(.. stringed-case :?) `#(= $ ,i)])
        (tset stringed-cases i (tostring case))))

    `(let [this-enum# [,(unpack stringed-cases)]]
       (each [k# v# (ipairs this-enum#)]
         ;; this-enum.CASE will return the int
         (tset this-enum# v# k#)
         ;; this-enum.case? will check equality with the int
         (tset this-enum# (.. v# :?) #(= $ k#)))
       this-enum#)))
#+END_SRC

#+BEGIN_SRC fennel :noweb-ref token-types
(local token-types
       (enum str number symbol kw-str
             opener closer prefix
             whitespace comment))
#+END_SRC

** TODO COMMENT Intro to state machines
** TODO COMMENT State machine macro based on enum and match

- Generates a function of ~(state ... args) -> (newState ... returns)~
-

#+BEGIN_SRC fennel :tangle test-state-machine.fnl
((require :busted.runner))

(local describe describe)
(local assert assert)
(local it it)

(require-macros :state-machine)

(describe "state-machine"
  #(do
     (let [(str-reader-machine str-reader-states)
           (state-machine

            ;; State spec
            ;;
            ;; Each state is followed by the states it's allowed to
            ;; transition to. The state-machine macro ensures that we
            ;; always return a new state or throw an error, that we
            ;; always transition states according to the spec, and that
            ;; we haven't omitted any transitions that are included in
            ;; the spec.

            [start [base]
             begin [base]
             base [base backslash end]
             backslash [base]
             end []]

            ;; Options
            ;;
            ;; If :default-state is set, calling the state machine with
            ;; a nil first argument will instead use this initial
            ;; state, and the macro will ensure that all other states
            ;; are reachable from this initial state. The
            ;; :default-state must be a member of :initial-states
            ;;
            ;; If :initial-states is set, the state machine will ensure
            ;; that all states are reachable from at least one of the
            ;; initial states.
            ;;
            ;; :initial-state can be used to set both :initial-states
            ;; and :default-state. Using :initial-state alongside
            ;; either of the other options causes an error.

            {:initial-states [start begin]
             :default-state start
             :on-err error}

            ;; Bind any additional arguments to the state machine
            [b]

            ;; Condition blocks
            ;;
            ;; Each condition block has three parts:
            ;;
            ;; - Previous state
            ;;
            ;; - Condition: a predicate body in which the above
            ;;   arguments are bound
            ;;
            ;; - Result: either another state (as per the above spec)
            ;;   or an error string literal. If this is a state, it
            ;;   must be a valid state to transition to according to
            ;;   the above spec.

            (start (= b 34) base
                   _ "expected opening quote")
            (base  (= b 92) backslash
                   (= b 34) done
                   (not b) "unterminated string"
                   _ base)
            (backslash _ base)
            (end _ "already finished reading string"))]
       nil)))
#+END_SRC

#+BEGIN_SRC fennel :tangle state-machine.fnl
(global unpack (or unpack table.unpack))
(fn enum [...]
  (let [cases [...]
        stringed-cases []]

    (each [i case (ipairs cases)]
      (let [stringed-case (tostring case)]
        ;; (tset kv-pairs adjusted-i [i stringed-case])
        ;; (tset kv-pairs (+ adjusted-i 1) [stringed-case i])
        ;; (tset kv-pairs (+ adjusted-i 2) [(.. stringed-case :?) `#(= $ ,i)])
        (tset stringed-cases i (tostring case))))

    `(let [this-enum# [,(unpack stringed-cases)]]
       (each [k# v# (ipairs this-enum#)]
         ;; this-enum.CASE will return the int
         (tset this-enum# v# k#)
         ;; this-enum.case? will check equality with the int
         (tset this-enum# (.. v# :?) #(= $ k#)))
       this-enum#)))

(fn split-alternating [tab]
  (let [odds [] evens []]
    (each [i val (ipairs tab)]
      (if (= 1 (% i 2))
          (tset odds (-> i (- 1) (/ 2) (+ 1)) val)
          (tset evens (/ i 2) val)))
    (values odds evens)))

(fn expand-condition-transition-pair [condition transition]
  (let [t (type transition)]
    (when (not (or (= t :string) (sym? t)))
      (error "expected result to be either an error string or a state symbol")))

  (let [err-cond? (= :string (type transition))
        err-message (if err-cond? transition "")
        final-condition (if (and (sym? condition) (= :_ (tostring condition))) (sym :true)
                            condition)]
    ))

(fn expand-condition-block-with-states-and-transitions [states transitions previous condition-block]
  (let [form `(if)
        form-i (length form)
        [from-state] condition-block]
    (for [i 2 (length condition-block)])))

(fn map-values [fun item ...]
  (when (not= item nil)
    (values (fun item) (map-values fun ...))))

(fn state-machine [spec options args ...]
  (let [options
        (if (or (not= (type options) :table) (sequence? options))
            (error "state-machine options must be a sequence literal")
            options)

        (initial-state-syms default-state-sym)
        (let [o options]
          (if (and o.initial-state o.initial-states)
              (error "both initial-state and initial-states are set")

              (and o.initial-state o.default-state)
              (error "both initial-state and default-state are set")

              o.initial-states (values o.initial-states o.default-state)
              o.initial-state (values [o.initial-state] o.initial-state)))

        transition-forms [...]
        (state-syms allowed-transition-lists) (split-alternating spec)
        states (eval-ast (enum (unpack state-syms)))
        transitions {}
        condition-blocks [...]
        expand-condition-block
        (partial expand-condition-block-with-states-and-transitions states transitions)
        expand-condition-blocks (partial map-values expand-condition-block)]

    (each [i state-sym (ipairs state-syms)]
      (let [allowed-transition-list (. allowed-transition-lists i)]
        (tset transitions (tostring state-sym) allowed-transition-list)))

    (each [i state-sym (ipairs state-syms)]
      (let [allowed-transition-list (. allowed-transition-lists i)]
        (each [j to-state-sym (ipairs allowed-transition-list)]
          (when (not (. transitions (tostring to-state-sym)))
            (error (.. "invalid transition from " (tostring state-sym)
                       ": " (tostring to-state-sym) " is not a state"))))))

    `(let [states-enum# ,(enum (unpack state-syms))
           machine#
           (fn [prev-state ,(unpack args)]
             (match state
               ,(expand-condition-blocks ...)))]
       (values states-enum#))))

{: enum : split-alternating : state-machine}
#+END_SRC

** Readers
Our tokenizer will take stateful stream of bytes and create a [[#get-stream-cursor][cursor]]
over it.

Our readers are not actually single functions, but rather a table
containing a few functions which collect tokens in different ways. All
the functions take the same argument. Named ~peek~, it should be a
function that allows the reader to check the values of bytes relative
to the cursor's current position. We'll be using ~cursor.peek~ defined
above.

- ~readn~ - takes a ~peek~ function, and uses it to check how many bytes
  it should read. Returns 0 if the reader cannot read a token at the
  current cursor position, or ~n~ where ~n~ is the number of bytes to
  read.
- ~read-bytes~ - takes a cursor, which it advances over the next token,
  returning the bytes of that token.
- ~read-string~ - advances the reader over the next token and returns it
  as a string.


We can use a function which takes a ~readn~ function as an argument to
generate a reader with all the functions just described :

#+BEGIN_SRC fennel :noweb-ref create-reader
(fn create-reader [readn]
  (fn read-bytes [cursor]
    (let [n (readn cursor.peek)] (cursor.take n)))
  (fn read-string [cursor]
    (-> cursor read-bytes string.char))
  {: readn : read-bytes : read-string})
#+END_SRC

This allows us to construct readers as follows:

#+BEGIN_SRC fennel
;; Example - not a part of the source code!

(create-reader
 (fn [peek]
   ;; - peek is a cursor's peek function

   ;; This is a normal fennel function body. Its return value should be
   ;; 0 if the reader cannot currently take a token, or a number of
   ;; bytes to take for the next token.
   )
#+END_SRC

We can compose readers by running them in sequence, then using the
first reader that returns a token size greater than 0.

#+BEGIN_SRC fennel :noweb-ref compose-tagged-readers
(fn split-alternating [tab]
  (let [odds [] evens []]
    (each [i val (ipairs tab)]
      (if (= 1 (% i 2))
          (tset odds (-> i (- 1) (/ 2) (+ 1)) val)
          (tset evens (/ i 2) val)))
    (values odds evens)))

(fn compose-tagged-readers [...]
  (let [(tags readers) (split-alternating [...])
        readn-tagged-inner
        (fn readn-tagged-inner [peek i]
          (let [tag (. tags i) reader (. readers i)]
            (if (= reader nil) (values nil 0)
                (let [n (reader.readn peek)]
                  (if (> n 0) (values tag n)
                      (readn-tagged-inner peek (+ i 1)))))))
        readn-tagged (fn [peek] (readn-tagged-inner peek 1))
        read-bytes-tagged
        (fn [cursor]
          (let [(tag n) (readn-tagged cursor.peek)]
            (values tag (cursor.take n))))
        read-string-tagged-inner
        (fn [tag ...]
          (values tag (string.char ...)))
        read-string-tagged
        (fn [cursor]
          (read-string-tagged-inner (read-bytes-tagged cursor)))
        readn (fn [peek] (select 2 (readn-tagged peek)))
        {: read-bytes : read-string} (create-reader readn)]
    {: readn
     : read-bytes
     : read-string
     : readn-tagged
     : read-bytes-tagged
     : read-string-tagged}))
#+END_SRC

*** Tests                                                        :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe "compose-tagged-readers"
  #(let [{:streams {: stateful-string-stream : create-cursor}
          :readers {: whitespace-reader : symbol-reader : keyword-string-reader}
         : compose-tagged-readers} (require :fennel-the-book)]
     (it "should compose readers"
       #(let [composed-reader (compose-tagged-readers 1 whitespace-reader
                                                      2 symbol-reader
                                                      3 keyword-string-reader)
              s " sym :kw-string sym-2 :another-kw-string"
              cursor (create-cursor (stateful-string-stream s))]
          (assert.are.same [1 1] [(composed-reader.readn-tagged cursor.peek)])
          (assert.are.same [32] [(composed-reader.read-bytes cursor)])
          (assert.are.same [2 115 121 109] [(composed-reader.read-bytes-tagged cursor)])
          (assert.are.same [1 " "] [(composed-reader.read-string-tagged cursor)])
          (assert.are.same [3 ":kw-string"] [(composed-reader.read-string-tagged cursor)])))))
#+END_SRC

*** TODO COMMENT Test/provide UTF-8 aware string reconstitution
see https://github.com/starwing/luautf8
*** DONE COMMENT Rewrite readers to use ~readn~ interface
- [X] whitespace
- [X] comment
- [X] symbol
- [X] kw-string
- [X] string
- [X] number
*** DONE COMMENT Write reader tests
*** DONE COMMENT Rename collectors to readers
*** DONE COMMENT Rewrite readers recursively to remove explicit loops
- [X] whitespace
- [X] comment
- [X] symbol
- [X] kw-string
- [X] string
- [X] number

*** Whitespace reader
The whitespace reader takes or skips all the whitespace bytes at
the beginning of its cursor argument's stream. Whitespace is defined
as any of the following bytes:

- 9 (~^I~, tab)
- 10 (~^J~, line feed)
- 11 (~^K~, vertical tab)
- 12 (~^L~, form feed)
- 13 (~^J~, carriage return)
- 32 (space)

#+BEGIN_SRC fennel :noweb-ref whitespace-reader
(fn whitespace? [b]
  (and b (or (= b 32)
             (and (>= b 9) (<= b 13)))))

(fn read-whitespace [peek n]
  (let [n (or n 1)]
    (if (whitespace? (peek n 1))
        (read-whitespace peek (+ n 1))
        (- n 1))))

(local whitespace-reader (create-reader (fn [peek] (read-whitespace peek))))
#+END_SRC

**** Tests                                                      :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe "whitespace reader"
  #(let [{:streams {: stateful-string-stream : create-cursor}
          :readers {: whitespace-reader}} (require :fennel-the-book)
         create-string-cursor #(-> $ stateful-string-stream create-cursor)
         read-whitespace-string #(-> $ create-string-cursor whitespace-reader.read-string)]
     (it "should readn a string with just whitespace"
       #(let [s " " cursor (create-string-cursor s)]
          (assert.are.equal 1 (whitespace-reader.readn cursor.peek))))
     (it "should read a string with just whitespace"
       #(let [s " 	\n"] (assert.are.equal s (read-whitespace-string s))))
     (it "should read only the beginning of a string that starts with whitespace"
       #(let [s "  abc"] (assert.are.equal "  " (read-whitespace-string s))))
     (it "should return 0 for a string that doesn't start with whitespace"
       #(let [s "abc  " cursor (create-string-cursor s)]
          (assert.are.equal 0 (whitespace-reader.readn cursor.peek))
          (assert.are.equal "" (read-whitespace-string s))))))
#+END_SRC

*** Comment reader
The comment reader is also quite simple. Since Fennel has only
line-based comments, we simply check that the initial byte is a
semicolon (value 59) and then get all the bytes until the next newline
(value 10).
#+BEGIN_SRC fennel :noweb-ref comment-reader
(fn read-comment [peek n]
  (let [n (or n 1)
        peeked (peek n 1)]
    (if (and (= n 1) (not= peeked 59)) 0
        (or (not peeked)
            (and (not= n 1) (= peeked 10))) (- n 1)
        (read-comment peek (+ n 1)))))

(local comment-reader (create-reader (fn [peek] (read-comment peek))))
#+END_SRC

**** Tests                                                      :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe "comment reader"
  #(let [{:streams {: stateful-string-stream : create-cursor}
          :readers {: comment-reader}} (require :fennel-the-book)
         read-comment-string
         #(-> $ stateful-string-stream create-cursor comment-reader.read-string)]
     (it "should read a string with just a comment"
       #(let [s "; this is a comment"]
         (assert.are.equal s (read-comment-string s))))
     (it "should read only the beginning of a string that starts with a comment"
       #(let [s "; this is a comment\n:no-longer-a-comment"]
          (assert.are.equal "; this is a comment" (read-comment-string s))))))
#+END_SRC

*** Symbol reader
The symbol reader is relatively simple. A symbol character is
defined as any character except the following:

- Special characters with charcodes 32 and under (includes whitespace)
- Delimiters
- Single and double quotes
- Commas
- Semicolons
- DEL control character

Additionally, symbols cannot /begin/ with any of the following
characters, since they are ambiguous with numeric literals:

- Digits (0-9)
- Period

To track delimiters, we will use a ~delims~ table. Opening delimiters
have the corresponding closer as their value. Closing delimiters
simply have ~true~.

#+BEGIN_SRC fennel :noweb-ref delims
(local delims {40 41    ;; (
               41 true  ;; )
               91 93    ;; [
               93 true  ;; ]
               123 125  ;; {
               125 true ;; }
               })

(fn delim? [b] (not (not (. delims b))))
#+END_SRC

Now we can define a function that detects symbol characters based on
the above definition:

#+BEGIN_SRC fennel :noweb-ref symbol-char?
(fn symbol-char? [b]
  (and b
       (> b 32)
       (not (. delims b))
       (not= b 34)  ;; "
       (not= b 39)  ;; '
       (not= b 44)  ;; ,
       (not= b 59)  ;; ;
       (not= b 127) ;; DEL
       ))
#+END_SRC

And another function to check for digits, which cannot begin a symbol:

#+BEGIN_SRC fennel :noweb-ref digit-char?
(fn digit-char? [b] (and (> b 47) (< b 58)))
(fn disallowed-symbol-starter? [b]
  (or (not (symbol-char? b))
      (digit-char? b)
      ))
#+END_SRC

Now that we have that function, we can create a symbol reader
easily:

#+BEGIN_SRC fennel :noweb-ref symbol-reader
(fn read-symbol [peek n]
  (let [n (or n 1)
        char (peek n 1)]
    (if (and (= n 1) (disallowed-symbol-starter? char)) 0
        ;; a colon followed by symbol chars is a keyword string
        (and (= n 1) (= char 58) (symbol-char? (peek (+ n 1) 1))) 0
        (symbol-char? char) (read-symbol peek (+ n 1))
        (- n 1))))

(local symbol-reader (create-reader (fn [peek] (read-symbol peek))))
#+END_SRC

**** Tests                                                      :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe "symbol reader"
  #(let [{:streams {: create-string-cursor}
          :readers {: symbol-reader}} (require :fennel-the-book)
         read-symbol-string
         #(-> $ create-string-cursor symbol-reader.read-string)]
     (it "should read a string with just a symbol"
       #(let [s "symbol"]
         (assert.are.equal s (read-symbol-string s))))
     (it "should read only the beginning of a string that starts with a comment"
       #(let [s "a-symbol ; shouldn't read any more"]
          (assert.are.equal "a-symbol" (read-symbol-string s))))
     (it "shouldn't read a symbol that begins with a digit"
       #(let [s "0abc" cursor (create-string-cursor s)]
          (assert.are.equal 0 (symbol-reader.readn cursor.peek))
          (assert.are.equal "" (read-symbol-string s))))
     (it "should read and recreate UTF-8 symbol"
         #(let [s "コンニチハ" cursor (create-string-cursor s)]
            (assert.are.equal 15 (symbol-reader.readn cursor.peek))
            (assert.are.equal "コンニチハ" (read-symbol-string s))))))
#+END_SRC

*** Keyword string reader
Keyword strings are strings created by prefixing a symbol with the ~:~
character. Because of this, we can re-use the ~symbol-reader~ we've
just defined to collect the string after skipping the initial ~:~ character.

#+BEGIN_SRC fennel :noweb-ref keyword-string-reader
(fn read-keyword-string [peek n]
  (let [n (or n 1)
        char (peek n 1)]
    (if (and (= n 1) (not= (peek) 58)) 0
        (and (> n 1) (not (symbol-char? (peek n 1)))) (- n 1)
        (read-keyword-string peek (+ n 1)))))

(local keyword-string-reader (create-reader (fn [peek] (read-keyword-string peek))))
#+END_SRC

**** Test                                                       :noexport:

#+BEGIN_SRC fennel :tangle test.fnl
(describe "keyword string reader"
  #(let [{:streams {: create-string-cursor}
          :readers {: keyword-string-reader}} (require :fennel-the-book)
         read-keyword-string-string
         #(-> $ create-string-cursor keyword-string-reader.read-string)]
     (it "should read a keyword string"
       #(let [s ":kw-string"]
          (assert.are.equal s (read-keyword-string-string s))))))
#+END_SRC

*** String reader
Strings in Fennel are delimited with double quotes, which can be
escaped within the string using backslashes. Due to this escaping, the
string reader is the first to require an explicit state machine
within the reader itself. The possible states of this machine are
as follows:

- ~start~: takes the opening quote (erroring if it's not a quote), then
  transitions to ~base~.
- ~base~: take string bytes normally, looking for the next double-quote
  character (byte 34), and adds them to the string. Transitions to
  ~backslash~ if it sees a backslash character (byte 92).
- ~backslash~: takes and adds the next byte to the string, regardless of
  what byte it is, then transition back to ~base~.
- ~done~: close the collection loop and, if collecting, return the
  collected bytes.

#+BEGIN_SRC fennel :noweb-ref string-reader
(local string-reader-states (enum start base backslash done))
(fn read-string [peek n state]
  (let [n (or n 1)
        s string-reader-states
        state (or state s.start)]
    (if (= n 0) 0 ; n has been explicitly set to 0
        (= state s.done) (- n 1)
        (let [char (peek n 1)
              (new-state override-n)
              (match (values state char)
                (_ nil) (error "unterminated string")
                (s.start 34) s.base
                (s.start _) (values s.start 0)
                ((s.start ?b) ? (not ?b)) (values s.start 0)
                (s.base 92) s.backslash
                (s.base 34) s.done
                (s.base _) s.base
                (s.backslash _) s.base)
              new-n (or override-n (+ n 1))]
          (read-string peek new-n new-state)))))

(local string-reader (create-reader (fn [peek] (read-string peek))))
#+END_SRC

**** Tests                                                      :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe "string reader"
  #(let [{:streams {: create-string-cursor}
          :readers {: string-reader}} (require :fennel-the-book)
         read-string #(-> $ create-string-cursor string-reader.read-string)]
     (it "should parse a normal string containing whitespace"
       #(let [s "\"just some old regular string \r\n with some whitespace in\""]
          (assert.are.equal s (read-string s))))
     (it "should parse a string with a backslash escape"
       #(let [s "\" \\\\ \""] (assert.are.equal s (read-string s))))
     (it "should parse a string with an escaped quote"
       #(let [s "\" \\\" \""] (assert.are.equal s (read-string s))))
     (it "should parse a string with a backslash followed by an escaped quote"
       #(let [s "\" \\\\\\\" \""] (assert.are.equal s (read-string s))))
     (it "should stop parsing at the first unescaped quote"
       #(let [s "\"here is the string\" and here is the suffix"]
          (assert.are.equal "\"here is the string\"" (read-string s))))
     (it "should error on unterminated string"
       #(assert.has.error #(read-string "\"abcdef") "unterminated string"))))
#+END_SRC

*** Number Reader
The number reader is the most complicated reader, and includes a
rather involved state machine to keep track of the state of the
reader. In each step, the machine chooses a new step The possible
states of this machine are as follows (all transitions other than
those explicitly listed will result in an error):

- ~start~: the reader begins in this state, and chooses which state
  to transition to based on the first character. Transitions to
  ~negate~, ~dec-point~, ~leading-0~, or ~digit~.
- ~negate~: the reader has found a leading hyphen. Transitions to
  ~dec-point~, ~leading-0~, or ~digit~.
- ~dec-point~: the reader has found a decimal point. Transitions to
  ~exp~ or ~dec-digit~.
- ~hex-dec-point~: the reader has found a decimal point in a hex
  number. Transitions to ~hex-dec-digit~.
- ~leading-0~: the reader has found a leading zero. Transitions to
  ~dec-point~, ~digit~, ~exp~, or ~base-hex~.
- ~base-hex~: the reader has found a hex indicator
  character. Transitions to ~hex-dec-point~ or ~hex-digit~. May not end
  the number and will cause an error if it is the last character.
- ~digit~: the reader has found a digit before the decimal
  point. Transitions to ~dec-point~, ~digit~, or ~exp~.
- ~dec-digit~: the reader has found a digit after the decimal
  point. Acts identically to ~digit~ except that another decimal point
  will produce an error.
- ~hex-digit~: the reader has found a digit in a hex
  number. Transitions to ~hex-dec-point~ or ~hex-digit~.
- ~hex-dec-digit~: the reader has found a digit after the decimal
  point in a hex number. Acts identically to ~hex-digit~ except that
  another decimal point will produce an error.
- ~exp~: the ~e~ or ~E~ character has been found in a non-hex number,
  indicating that the number should be summed with 10 to the given
  power. Transitions to ~exp-negate~ or ~exp-digit~. May not end the
  number and will cause an error if it is the last character.
- ~exp-negate~: a hyphen has been found immediately following an
  exponent indicator. Transitions to ~exp-digit~. May not end the number
  and will cause an error if it is the last character.
- ~exp-digit~: a digit in the tens-exponent portion of the number has
  been found. Transitions to ~exp-digit~.

#+BEGIN_SRC fennel :noweb-ref number-reader
(fn hex-letter-digit-char? [b] (or (and (> b 64) (< b 71))
                                   (and (> b 96) (< b 103))))
(fn hex-digit-char? [b] (or (digit-char? b) (hex-letter-digit-char? b)))
(fn exponent-char? [b] (or (= b 69) (= b 101)))
(fn hex-indicator-char? [b] (or (= b 88) (= b 120)))
(fn number-char? [b]
  (or (digit-char? b)
      (= b 46) ; 0
      ))

(fn err-unexpected-char [b message]
  (error (.. "malformed number: unexpected char \"" (string.char b) "\" " message)))

(local number-reader-states
  (enum start negate dec-point hex-dec-point
        leading-0 base-hex digit dec-digit
        hex-digit hex-dec-digit
        exp exp-negate exp-digit))

(fn err-unhandled-state-transition [state b]
  (error (.. "unhandled state transition in number parser!\tstate: " (. number-reader-states state)
           "\tbyte: " (or b "<nil>") "\tchar: " (or (string.char b) "<nil>"))))

(fn err-invalid-number-character [state b]
  (error (.. "invalid char in number: " (string.char b) "\tchar value: " b)))

;; takes a state and byte (which can potentially be nil) and returns a
;; new state. returning :end will end the collection loop, ignoring
;; the final byte that the state machine was called with
(fn number-reader-state-machine [state byte]
  (let [s number-reader-states]
    (match (values state byte)

      ;; --- start ---
      (s.start 45) s.negate
      (s.start 46) s.dec-point
      (s.start 48) s.leading-0
      ((s.start b) ? (digit-char? b)) s.digit

      ((s.start b) ? (exponent-char? b))
      (error "malformed number: unexpected leading exponent char")

      ((s.start b) ? (hex-indicator-char? b))
      (error "malformed number: unexpected leading hex indicator char")

      ;; --- negate ---
      (s.negate 46) s.dec-point
      (s.negate 48) s.leading-0
      ((s.negate b) ? (digit-char? b)) s.digit
      (s.negate b) (err-unexpected-char b "following negation char")

      ;; --- dec-point ---
      ((s.dec-point b) ? (exponent-char? b)) s.exp
      ((s.dec-point b) ? (digit-char? b)) s.dec-digit
      (s.dec-point b) (err-unexpected-char b "following decimal point")

      ;; --- hex-dec-point
      ((s.hex-dec-point b) ? (hex-digit-char? b)) s.hex-dec-digit
      (s.hex-dec-point b) (err-unexpected-char b "following decimal point")

      ;; --- leading-0 ---
      (s.leading-0 45) (error "unexpected hyphen following leading zero")
      (s.leading-0 46) s.dec-point
      ((s.leading-0 b) ? (digit-char? b)) s.digit
      ((s.leading-0 b) ? (exponent-char? b)) s.exp
      ((s.leading-0 b) ? (hex-indicator-char? b)) s.base-hex

      ;; --- base-hex ---
      (s.base-hex 46) s.hex-dec-point
      ((s.base-hex b) ? (hex-digit-char? b)) s.hex-digit
      (s.base-hex b) (err-unexpected-char b "following hex indicator char")

      ((s.base-hex ?b) ? (not ?b))
      (error "unexpected end of number following hex indicator char")

      ;; --- digit ---
      (s.digit 45) (error "unexpected hyphen following digit")
      (s.digit 46) s.dec-point
      ((s.digit b) ? (digit-char? b)) s.digit
      ((s.digit b) ? (exponent-char? b)) s.exp

      ((s.digit b) ? (hex-letter-digit-char? b))
      (error "unexpected hex digit in non-hex number")

      ((s.digit b) ? (hex-indicator-char? b))
      (error "unexpected hex indicator char following digit")

      ;; --- dec-digit ---
      (s.dec-digit 46) (error "unexpected second decimal point")
      ((s.dec-digit b) ? (digit-char? b)) s.dec-digit

      ;; reuse s.digit state for all other cases
      (s.dec-digit ?b) (number-reader-state-machine s.digit ?b)

      ;; --- hex-digit ---
      (s.hex-digit 45) (error "unexpected hyphen following digit")
      (s.hex-digit 46) s.hex-dec-point
      ((s.hex-digit b) ? (hex-digit-char? b)) s.hex-digit

      ((s.hex-digit b) ? (hex-indicator-char? b))
      (error "unexpected hex indicator char following digit")

      ;; --- hex-dec-digit ---
      (s.hex-dec-digit 46) (error "unexpected second decimal point")
      ((s.hex-dec-digit b) ? (digit-char? b)) s.hex-dec-digit

      ;; reuse s.hex-digit state for all other cases
      (s.hex-dec-digit ?b) (number-reader-state-machine s.hex-digit ?b)

      ;; --- exp ---
      (s.exp 45) s.exp-negate
      ((s.exp b) ? (digit-char? b)) s.exp-digit
      (s.exp b) (err-unexpected-char b "following exponent char")

      ((s.exp ?b) ? (not ?b))
      (error "unexpected end of number following exponent char")

      ;; --- exp-negate ---
      ((s.exp-negate b) ? (digit-char? b)) s.exp-digit
      (s.exp-negate b) (err-unexpected-char b "following exponent hyphen char")

      ((s.exp-negate ?b) ? (not ?b))
      (error "unexpected end of number following exponent hyphen char")


      ;; --- exp-digit ---
      ((s.exp-digit b) ? (digit-char? b)) s.exp-digit

      (s.exp-digit b)
      (error "unexpected char \"" (string.char b) "\" following exponent digit char")

      ((_ ?b) ? (or (not ?b) (whitespace? ?b) (delim? ?b))) s.end

      ;; catch all other states
      _ (err-invalid-number-character state byte))))

(fn check-for-number [peek]
  (let [b (peek)]
    (or (digit-char? b) ;; leading digits always indicate a number
        (let [b2 (peek 2 1)]
          (or (and (or (= b 45) (= b 46)) (digit-char? b2)) ;; e.g. -1 or .1
              (let [b3 (peek 3 1)]
                (and (= b 45) (= b2 46) (digit-char? b3)))))))) ;; e.g. -.1

(fn read-number [peek n state]
  (let [n (or n 1)]
    (if (and (= n 1) (not (check-for-number peek))) 0
        (let [s number-reader-states
              state (or state s.start)
              char (peek n 1)
              new-state (number-reader-state-machine state char)]
          (if (= new-state s.end) (- n 1)
              (read-number peek (+ n 1) new-state))))))

(local number-reader (create-reader (fn [peek] (read-number peek))))
#+END_SRC

**** Tests                                                      :noexport:
#+BEGIN_SRC fennel :tangle test.fnl
(describe "number reader"
  #(let [{:streams {: stateful-string-stream : create-cursor}
          :readers {: number-reader}} (require :fennel-the-book)
         read-number #(-> $ stateful-string-stream create-cursor (number-reader.read-string error))]
     (it "should parse a number"
       #(let [s "12345"] (assert.are.equal s (read-number s))))
     (it "should parse a negative number"
       #(let [s "-12345"] (assert.are.equal s (read-number s))))
     (it "should stop parsing a number when it ends"
       #(assert.are.equal "12345" (read-number "12345 some words")))
     (it "should parse a number with a decimal point"
       #(let [s "123.45"] (assert.are.equal s (read-number s))))
     (it "should parse a negative number"
       #(let [s "-123.45"] (assert.are.equal s (read-number s))))
     (it "should parse a hexadecimal number"
       #(let [s "0xabc123"] (assert.are.equal s (read-number s))))
     (it "should parse a hexadecimal number with a decimal point"
       #(let [s "0xabc123.def456"] (assert.are.equal s (read-number s) )))
     (it "should parse a negative hexadecimal number with a decimal point"
       #(let [s "-0xabc123.def456"] (assert.are.equal s (read-number s))))
     (it "should parse a number with an exponent"
       #(let [s "1.514e10"] (assert.are.equal s (read-number s))))
     (it "should parse a number with a negative exponent"
       #(let [s "1.514e-10"] (assert.are.equal s (read-number s))))

     (it "should not allow non-digits"
       #(assert.has.error #(read-number "123z456") "invalid char in number: z\tchar value: 122"))
     (it "should not a allow a number to end with a hexadecimal indicator"
       #(assert.has.error #(read-number "0x") "unexpected end of number following hex indicator char"))
     (it "should not allow a number to end with an exponent indicator"
       #(assert.has.error #(read-number "1.514e") "unexpected end of number following exponent char"))
     (it "should not allow a number to end with an exponent hyphen"
       #(assert.has.error #(read-number "1.514e-") "unexpected end of number following exponent hyphen char"))
     (it "should not allow a number to contain two decimal points"
       #(assert.has.error #(read-number "1.514.625") "unexpected second decimal point"))
     (it "should not allow a hexadecimal number to contain two decimal points"
       #(assert.has.error #(read-number "0xa1.b2.c3") "unexpected second decimal point"))
     (it "should not allow a hex indicator character to come in the middle of a number"
       #(assert.has.error #(read-number "01xabc2") "unexpected hex indicator char following digit"))
     ))
#+END_SRC

**** DONE COMMENT use an integer enum instead of a string for the reader state
**** COMMENT attempted rewrite
#+BEGIN_SRC fennel
;; attempted rewrite of state machine before realizing it wouldn't
;; automatically skip the expected end of the number

(match state
  s.start
  (match byte
    45 s.negate
    46 s.dec-point
    48 s.leading-0
    (b ? (digit-char? b)) s.digit
    (b ? (exponent-char? b)) (err "unexpected leading exponent char")
    (b ? (hex-indicator-char? b)) (err "unexpected leading hex indicator char"))

  s.negate
  (match byte
    46 s.dec-point
    48 s.leading-0
    (b ? (digit-char? b)) s.digit
    _ (err-unexpected-char err byte "following negation char"))

  s.dec-point
  (match byte
    (b ? (exponent-char? b)) s.exp
    (b ? (digit-char? b)) s.dec-digit
    _ (err-unexpected-char err byte "following decimal point"))

  s.leading-0
  (match byte
    45 (err "unexpected hyphen following leading zero")
    46 s.dec-point
    (b ? (digit-char? b)) s.digit
    (b ? (exponent-char? b)) s.exp
    (b ? (hex-indicator-char? b)) s.base-hex)

  s.base-hex
  (match byte
    46 s.hex-dec-point
    (b ? (hex-digit-char? b)) s.hex-digit
    (?b ? (not ?b)) (err "unexpected end of number following hex indicator char")
    _ (err-unexpected-char err byte "following hex indicator char"))

  s.hex-dec-point
  (match byte
    (b ? (hex-digit-char? b)) s.hex-dec-digit
    _ (number-reader-state-machine err s.dec-point byte))

  s.digit
  (match byte
    45 (err "unexpected hyphen following digit")
    46 s.dec-point
    (b ? (digit-char? b)) s.digit
    (b ? (exponent-char? b)) s.exp)
  )
#+END_SRC

*** Other Readers
#+BEGIN_SRC fennel :noweb-ref other-readers
(local prefixes {96 :quote 44 :unqote 39 :quote 35 :hashfn})
(local prefix-reader
  (create-reader (fn [peek]
                   (if (and (. prefixes (peek))
                            (let [next-b (peek 2 1)]
                              (not (or (whitespace? next-b)
                                       (= (type (. delims next-b)) :boolean))))) 1
                       0))))

(local opener-reader
  (create-reader (fn [peek]
                   (if (= (type (. delims (peek))) :number) 1
                       0))))

(local closer-reader
  (create-reader (fn [peek]
                   (if (= (. delims (peek)) true) 1
                       0))))
#+END_SRC

*** Reader output :noexport:
#+BEGIN_SRC fennel :noweb yes :noweb-ref readers
<<create-reader>>
<<reader>>
<<compose-tagged-readers>>

<<whitespace-reader>>
<<comment-reader>>
<<string-reader>>

<<delims>>
<<symbol-char?>>
<<digit-char?>>
<<symbol-reader>>
<<keyword-string-reader>>

<<number-reader>>

<<other-readers>>
#+END_SRC

** Building the Tokenizer
Our tokenizer will take a stream of bytes and, using the readers
already defined, output a stream of tokens.

#+BEGIN_SRC fennel :noweb-ref tokenizer
(local fennel-tagged-reader
  (let [tts token-types]
    (compose-tagged-readers tts.str string-reader
                            tts.number number-reader
                            tts.opener opener-reader
                            tts.closer closer-reader
                            tts.whitespace whitespace-reader
                            tts.comment comment-reader
                            tts.prefix prefix-reader
                            tts.kw-str keyword-string-reader
                            tts.symbol symbol-reader)))

(fn take-token [cursor]
  (let [n (fennel-tagged-reader.readn cursor.peek)]
    (if (> n 0) (fennel-tagged-reader.read-bytes-tagged cursor)
        (let [(b1 b2 b3) (cursor.peek 3)]
          (error (.. "unrecognized byte sequence [" b1 " " b2 " " b3 "] "
                     "\"" (string.char b1 b2 b3) "\""))))))

(fn granulate [get-chunk]
  (var chunk "")
  (var index 1)
  (var done false)
  (values
   (fn [parser-state]
     (if done nil

         (<= index (length chunk))
         (let [byte (chunk:byte index)]
           (set index (+ index 1))
           byte)

         (do (set chunk (get-chunk parser-state))
             (if (or (not chunk) (= chunk ""))
                 (set done true)

                 (do (set index 2)
                     (chunk:byte 1))))))
   (fn [] (set chunk ""))))

(fn byte-stream->token-stream [bytes-stream]
  (let [cursor (create-cursor bytes-stream)]
    (fn [] (when (cursor.peek) (take-token cursor)))))

(fn separate-values-by-spaces-and-end-with-line [v ...]
  (if v (values v " " (separate-values-by-spaces-and-end-with-line ...))
      "\n"))

(fn token-loop [token-stream token-type ...]
  (when token-type
    (io.stdout:write (. token-types token-type) "\t"
                     ;(string.char ...) "\t"
                     (separate-values-by-spaces-and-end-with-line ...))
    (token-loop token-stream (token-stream))))

(fn tokenize-self []
  (let [chunk-size 8000
        f (assert (io.open "/home/benaiah/dev/fennel-the-book/fennel-the-book.fnl"))
        chunk-stream #(f:read chunk-size)
        byte-stream (granulate chunk-stream)
        token-stream (byte-stream->token-stream byte-stream)]
    token-stream))

(fn print-tokens-of-self []
  (let [s (tokenize-self)]
    (token-loop s (s))))
#+END_SRC

*** TODO COMMENT Rewrite tokenizer to use ~compose-readers~
* Parsing
#+BEGIN_SRC fennel :noweb-ref parser
(local fennelview (require :fennelview))
(fn token-stream->form-stream [token-stream]
  (let [cursor (create-cursor token-stream)
        stack []]
    (fennelview (cursor.peek))))

;; (let [chunk-size 8000
;;       f (assert (io.open "/home/benaiah/dev/fennel-the-book/fennel-the-book.fnl"))
;;       token-stream (-> #(f:read chunk-size) granulate byte-stream->token-stream)]

;;   (for [i 1 10]
;;      (-> [(token-stream)]
;;          (#[(. token-types (. $ 1)) (. $ 2)])
;;          fennelview
;;          print)))
#+END_SRC
* COMMENT Tools
** TODO ~fennel-fmt~
#+BEGIN_SRC fennel
#+END_SRC

** TODO ~fawk~
#+BEGIN_SRC fennel :noweb tangle :tangle fawk.fnl
(local fs "\n")
#+END_SRC
* Misc.
** Hashbang
To allow the file to be run as an executable on Linux, we add a
hashbang to the first line. As noted above, the tokenizer treats this
line as a comment if it is the very first thing in the file.

#+BEGIN_SRC fennel :noweb-ref hashbang
#!/usr/bin/env fennel
#+END_SRC

** Utils
#+BEGIN_SRC fennel :tangle utils.fnl

#+END_SRC

** Tests                                                          :noexport:
*** TODO COMMENT Set up tests
* Book tooling
This section contains Fennel tooling used to create this book.

** JS for HTML output
#+BEGIN_SRC fennel :tangle fennel-the-book-html-script.fnl
(: js.global.console :log :hello-world)
(: js.global :alert "hello")
(: js.global.console :log js.global)
nil
#+END_SRC

** Org table helper
#+BEGIN_SRC fennel :tangle org-table-helpers.fnl
;; Exported to org-table-helpers.fnl

(local fennelview (require :fennelview))

(fn fast-push [t v]
  (set t.__count (+ (or t.__count 0) 1))
  (tset t t.__count v))

(fn fast-length [t] (or t.__count (length t)))

(fn make-table [rows options]
  (let [{: column-headers : column-groups} (or options {})
        column-headers-row
        (and column-headers (= :table (type column-headers))
             column-headers)
        column-widths []
        processed-rows []
        hlines-after {}
        chunks []]

    (var table-cell-width 0)

    (when column-headers-row (table.insert rows 1 column-headers-row))
    (when column-groups (table.insert rows 2 column-groups))

    ;; collect table widths and convert cells to strings
    (each [row-i row (ipairs rows)]
      (local processed-cells [])
      (each [cell-i cell (ipairs row)]
        (let [val (if (= :string (type cell)) cell
                      (fennelview cell {:one-line true}))
              val-width (length val)]

          ;; update column width if it's smaller than the current cell
          (when (> val-width (or (. column-widths cell-i) 0))
            (tset column-widths cell-i val-width))

          ;; update table cell width
          (when (> cell-i table-cell-width) (set table-cell-width cell-i))
          (fast-push processed-cells val)))
      (fast-push processed-rows processed-cells))

    (local table-cell-height (fast-length processed-rows))

    ;; print the cells to the chunks table
    (each [row-i row (ipairs processed-rows)]
      (fast-push chunks "|") ;; left border
      (for [cell-i 1 table-cell-width]
        (let [cell (or (. row cell-i) "")
              cell-width (length cell)]
          (fast-push chunks " ")
          (fast-push chunks cell)
          (local right-cell-padding
                 (math.max 0 (- (. column-widths cell-i) cell-width)))
          (local right-padding (+ 1 right-cell-padding))
          (fast-push chunks (string.rep " " right-padding))
          (fast-push chunks "|") ;; right border
          ))
      (when (not= row-i table-cell-height)
        (fast-push chunks "\n"))
      (when (and column-headers (= row-i 1))
        (fast-push chunks "|")
        (each [column-i width (ipairs column-widths)]
          (fast-push chunks (string.rep "-" (+ width 2)))
          (fast-push chunks (if (= column-i table-cell-width) "|" "+")))
        (fast-push chunks "\n")))

    (table.concat chunks)))

{: make-table :print-table (fn [...] (print (make-table ...)))}
#+END_SRC

*** COMMENT Old value-based org table helper
#+BEGIN_SRC fennel
(fn org-table-helper [rows options]
  (let [fennelview (require :fennelview)
        processed-rows []
        {: headers} (or options {})]
    (each [i row (ipairs rows)]
      (local processed-row
             (if (= (type row) :table)
                 (let [processed-cells []]
                   (each [i cell (ipairs row)]
                     (table.insert
                      processed-cells
                      (if (= :number (type cell))
                          (= :table (type cell)) (.. "\"" (fennelview cell {:one-line true}) "\"")
                          (fennelview cell {:one-line true}))))
                   (.. "(" (table.concat processed-cells " ") ")"))
                 row))
      (table.insert processed-rows processed-row)
      (when (and (= i 1) headers)
        (table.insert processed-rows "hline")))
    (.. "(" (table.concat processed-rows " ") ")")))
#+END_SRC

** Makefile

The makefile is committed to the repo so that ~make tangle~ can be run.

#+BEGIN_SRC makefile :tangle makefile
.PHONY: tangle
tangle:
	emacs --batch --eval "(require 'org)" --eval '(org-babel-tangle-file "fennel-the-book.org")'

.PHONY: test
test:
	fennel test.fnl
#+END_SRC

* Output                                                           :noexport:
#+BEGIN_SRC fennel :noweb tangle :tangle fennel-the-book.fnl

(global unpack (or unpack table.unpack))
;; (macro → [...] `(-> ,...))

<<enum>>

<<stateful-string-stream>>

<<create-cursor>>

<<create-string-cursor>>

<<token-types>>

<<readers>>

<<tokenizer>>

<<parser>>

{:streams {: stateful-string-stream : create-cursor : create-string-cursor}
 :readers {: whitespace-reader : comment-reader : symbol-reader : keyword-string-reader : number-reader : string-reader}
 : compose-tagged-readers
 : token-types
 : token-stream->form-stream
 : tokenize-self
 : print-tokens-of-self
 }
#+END_SRC
